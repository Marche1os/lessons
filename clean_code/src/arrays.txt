
1) Возьмем пример с кодом, подсчитывающий стоимость товаров в корзине:
    CartItem[] cartItems = getCartItems();

    double priceTotal = 0;
    for (CartItem item : cartItems) {
        priceTotal += (item.currentPrice * item.productCount);
        // accumulate priceTotal
    }

Используемый массив переписать в множество. Так уйдем от структуры с произвольным доступом, который в нашем случае не используется.
В множество наши элементы можем поместить, потому что нам не важен порядок элементов для данного случая, также не можем иметь дубликатов.

Set<CartItem> cartItemsSet = Set.of(getCartItems());
cartItemsSet.forEach(item -> {
    priceTotal += item.currentPrice;
});

2) Пример без прямой индексации. Возьмем список подписчиков у пользователя.
Задача - в списке их отобразить в порядке, который нам прислал сервер.
Код имеет вид
    List<Follower> followers = getMyFollowers();
    for (Follower follower : followers) {...}
Как видно, несмотря на использование структуры данных с произвольным доступом к элементу списка, мы не работаем с элементом по индексу.
А вместо того последовательно проходим по всему списку. Тем самым не имеем проблем с возможным некорректным обращением к элементу по индексу.

3) Пример с загрузкой нескольких изображений на сервер. По ограничениям, загружать изображения можно только по одной, последовательно.
В конец списка добавлялись выбранные пользователем фотографии, которые затем отправлялись на сервер.
То есть требовалось добавлять в конец массив и удалять с начала. Поэтому реализацию на основе массива можно перевести в тип "Очередь".

Было
private List<FileToUpload> filesToUpload = new ArrayList<>();

Стало
private Queue<FileToUpload> filesToUpload = new LinkedList<>();

4) Пример работы с массивом без прямого обращения по индексу в программе, определяющей сбалансированность скобок, подающихся на вход.
Здесь используется массив символов входной строки с дальнейшей последовательной итерацией по этому массиву.
Без обращения к конкретному элементу по индексу.

final char[] bracketsCharArray = brackets.toCharArray();
final Stack<Character> characterStack = new Stack<>();

for (Character item : bracketsCharArray) {
    //some logic...
}

5) Встретил код, в котором цвет RGB хранится в виде массива из 3 составляющих цвета:
int[] RGB = new int[3];

Хотя на первый взгляд и выглядит оверхедом, но можно представить цвет в виде пары ключ-значение:
Map<String, Integer> mapOfRGB = Map.of("red", 255, "green", 255, "blue", 255);

Ключи для такого случая лучше вынести в константы.